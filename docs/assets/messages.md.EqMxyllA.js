import{_ as e,o as s,c as a,R as n}from"./chunks/framework.LBXiIpgL.js";const o="/assets/message_sample.SWlbrD8M.png",t="/assets/youtube_attachement.SNkdWvBK.png",l="/assets/reactions.YVbZ8opb.gif",v=JSON.parse('{"title":"Messages","description":"","frontmatter":{},"headers":[],"relativePath":"messages.md","filePath":"messages.md"}'),p={name:"messages.md"},c=n(`<h1 id="messages" tabindex="-1">Messages <a class="header-anchor" href="#messages" aria-label="Permalink to &quot;Messages&quot;">​</a></h1><h2 id="description" tabindex="-1">Description <a class="header-anchor" href="#description" aria-label="Permalink to &quot;Description&quot;">​</a></h2><p>Un message fait bien entendu référence au texte que les utilisateurs s&#39;échangent.</p><p>Cependant, un message n&#39;est pas uniquement du texte. Un message porte avec lui une date, son auteur mais aussi du contenu associé, comme par exemple une image ou une vidéo.</p><p>De plus, les utilisateurs ont la possibilité d&#39;interagir avec les messages, soit en émettant une &quot;réaction&quot;, l&#39;emoji utilisé à la place du classique <em>like</em>, soit en y répondant avec un autre message.</p><p>Le type <code>Message</code> (<code>/modules/message/models/domain/Message.ts</code>) est utilisé pour représenter un message.</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">export</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">type</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Message</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">RichMessage</span><span style="color:#E1E4E8;">;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">export</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">type</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Message</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">RichMessage</span><span style="color:#24292E;">;</span></span></code></pre></div><p>Le seul type de message supporté est de type &quot;<code>rich</code>&quot; pour &quot;message enrichie&quot;.</p><p>Un <code>RichMessage</code> est un message avec un texte de type <code>RichText</code> ainsi que du contenu associé au texte présent dans la propriété <code>attachements</code>.</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">export</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">interface</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">RichMessage</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">extends</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">MessageBase</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#9ECBFF;">&quot;rich&quot;</span><span style="color:#E1E4E8;">&gt; {</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#FFAB70;">attachements</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">MessageAttachement</span><span style="color:#E1E4E8;">[];</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">export</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">interface</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">RichMessage</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">extends</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">MessageBase</span><span style="color:#24292E;">&lt;</span><span style="color:#032F62;">&quot;rich&quot;</span><span style="color:#24292E;">&gt; {</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#E36209;">attachements</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">MessageAttachement</span><span style="color:#24292E;">[];</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>Ce contenu est par exemple l&#39;URL d&#39;une image qui est contenu dans le message. Cela peut être également l&#39;ID d&#39;une vidéo Youtube, dont le lien a été envoyé dans le message. Ainsi ces <code>attachements</code> vont permettre d&#39;afficher le lecteur Youtube à chaque fois qu&#39;un message contient une URL Youtube. La même chose s&#39;applique pour les URLs vers des images, des vidéos et même des sites web.</p><p>Le type <code>RichText</code> lui englobe la saisie de l&#39;utilisateur. Il permet de séparer le texte, des liens HTTP, des mentions d&#39;utilisateurs au sein de la saisie.</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">export</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">interface</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">RichText</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#FFAB70;">tokens</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">RichTextToken</span><span style="color:#E1E4E8;">[];</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">export</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">interface</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">RichTextToken</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#FFAB70;">value</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">string</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#FFAB70;">type</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;rich&quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">|</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;link&quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">|</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;mention&quot;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">export</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">interface</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">RichText</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#E36209;">tokens</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">RichTextToken</span><span style="color:#24292E;">[];</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">export</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">interface</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">RichTextToken</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#E36209;">value</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">string</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#E36209;">type</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;rich&quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">|</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;link&quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">|</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;mention&quot;</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>La saisie de l&#39;utilisateur est donc découpée en &quot;tokens&quot; où chaque <em>token</em> est une portion de texte avec un type. Cette portion peut donc être un lien HTTP <code>link</code>, le nom d&#39;un utilisateur <code>mention</code> tagué avec le @ ainsi que du texte enrichie <code>rich</code> qui signifie que le texte peut potentiellement contenir du gras, de l&#39;italique etc.</p><h2 id="level-i" tabindex="-1">Level I <a class="header-anchor" href="#level-i" aria-label="Permalink to &quot;Level I&quot;">​</a></h2><h3 id="_1-saisie" tabindex="-1">1. Saisie <a class="header-anchor" href="#_1-saisie" aria-label="Permalink to &quot;1. Saisie&quot;">​</a></h3><p>Pouvoir récupérer la saisie d&#39;un utilisateur et l&#39;envoyer au serveur via le composant <code>MessageInput.vue</code>.</p><p>Utiliser le composant <code>RichTextEditor</code> (<code>@/app/components/ui</code>) à la place d&#39;un input pour récupérer le texte de type RichText saisie par l&#39;utilisateur.</p><h3 id="_1-saisie-1" tabindex="-1">1. Saisie <a class="header-anchor" href="#_1-saisie-1" aria-label="Permalink to &quot;1. Saisie&quot;">​</a></h3><p>Utiliser le <code>MessageService</code> pour envoyer le texte.</p><p>La variable <code>roomState</code> est le <em>state</em> du salon sélectionné (de type <code>RoomState</code>).</p><h3 id="_2-lister-les-messages" tabindex="-1">2. Lister les messages <a class="header-anchor" href="#_2-lister-les-messages" aria-label="Permalink to &quot;2. Lister les messages&quot;">​</a></h3><p>La liste des messages doit se trouver dans le composant <code>Room.vue</code>.</p><p>Utiliser le composant <code>Message.vue</code> pour pouvoir restituer un message de type <code>Message</code>.</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>Pour le moment, il est normal si les messages ne sont pas visibles. Commencer l&#39;étape 3 si vous voulez voir le texte de vos messages.</p></div><p>Utiliser la méthode <code>fetchMore</code> de <code>MessageService</code> pour récupérer des messages depuis le serveur.</p><p>Veillez à recharger les messages lorsque l&#39;on change de salon :</p><p>Lorsque que le salon change (via un clic dans la liste des salons par exemple) le <em>state</em> qui contient les messages n&#39;est pas automatiquement actualisé. Il faut donc surveiller les changements de salon en surveillant la <em>prop</em> <code>room</code>. Si <code>room</code> change alors il faut vider le <em>state</em> qui contient les messages de la room précédente via la méthode <code>reset()</code> du <code>store</code> et appeler la méthode <code>fetchMore</code> de nouveau.</p><p>Rappel de l&#39;utilisation de la fonction <code>watch</code> :</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">import</span><span style="color:#E1E4E8;"> { watch } </span><span style="color:#F97583;">from</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;vue&quot;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#F97583;">...</span></span>
<span class="line"><span style="color:#B392F0;">watch</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">	() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> props.propASurveiller,</span></span>
<span class="line"><span style="color:#E1E4E8;">	(</span><span style="color:#FFAB70;">value</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">oldValue</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">		</span><span style="color:#F97583;">...</span></span>
<span class="line"><span style="color:#E1E4E8;">	}</span></span>
<span class="line"><span style="color:#E1E4E8;">);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">import</span><span style="color:#24292E;"> { watch } </span><span style="color:#D73A49;">from</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;vue&quot;</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#D73A49;">...</span></span>
<span class="line"><span style="color:#6F42C1;">watch</span><span style="color:#24292E;">(</span></span>
<span class="line"><span style="color:#24292E;">	() </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> props.propASurveiller,</span></span>
<span class="line"><span style="color:#24292E;">	(</span><span style="color:#E36209;">value</span><span style="color:#24292E;">, </span><span style="color:#E36209;">oldValue</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">		</span><span style="color:#D73A49;">...</span></span>
<span class="line"><span style="color:#24292E;">	}</span></span>
<span class="line"><span style="color:#24292E;">);</span></span></code></pre></div><h3 id="_3-restituer-le-contenu-d-un-message" tabindex="-1">3. Restituer le contenu d&#39;un message <a class="header-anchor" href="#_3-restituer-le-contenu-d-un-message" aria-label="Permalink to &quot;3. Restituer le contenu d&#39;un message&quot;">​</a></h3><p>Au sein du composant <code>Message.vue</code>, utilisez le composant <code>RichText.vue</code> (<code>/app/components/ui</code>) pour afficher un texte de type <code>RichText</code> (on parle ici l&#39;interface TypeScript à ne pas confondre avec le composant).</p><p>Rajouter les informations manquantes de façon à obtenir ceci :</p><p><img src="`+o+'" alt="Message Sample"></p><h3 id="_4-gerer-les-retours-chariot" tabindex="-1">4. Gérer les retours chariot <a class="header-anchor" href="#_4-gerer-les-retours-chariot" aria-label="Permalink to &quot;4. Gérer les retours chariot&quot;">​</a></h3><p>Les <code>MessageDataParser</code> (<code>/modules/message/service/MessageDataParser.ts</code>) est une classe qui permet de transformer les messages qui proviennent directement du serveur (<code>MessageData</code>) dans le type <code>Message</code> adapté aux besoins de l&#39;interface via sa méthode <code>parse</code>.</p><p>Implémentez la méthode <code>replaceNewLines</code> du <code>MessageDataParser</code> qui permet de remplacer les retours chariots <code>\\n</code> contenus dans un <code>RichText</code>. Les retours chariots doivent être remplacés par leur équivalent HTML.</p><h3 id="_5-formatter-la-date" tabindex="-1">5. Formatter la date <a class="header-anchor" href="#_5-formatter-la-date" aria-label="Permalink to &quot;5. Formatter la date&quot;">​</a></h3><p>Utiliser la librairie <a href="https://moment.github.io/luxon/#/?id=luxon" target="_blank" rel="noreferrer">luxon</a> pour formatter la date.</p><p>L&#39;objet <code>DateTime</code> de luxon possède un méthode statique <code>DateTime.fromJSDate</code> pour créer une instance à partir d&#39;une date javaScript.</p><p>Vous pouvez utiliser une simple fonction dans votre <em>template</em> qui va faire la conversion entre la date JavaScript et une <code>string</code> formattée correctement.</p><h2 id="level-ii" tabindex="-1">Level II <a class="header-anchor" href="#level-ii" aria-label="Permalink to &quot;Level II&quot;">​</a></h2><h3 id="_1-temps-reel" tabindex="-1">1. Temps réel <a class="header-anchor" href="#_1-temps-reel" aria-label="Permalink to &quot;1. Temps réel&quot;">​</a></h3><p>Insérez les nouveaux messages reçus via Websocket. Le services <code>MessageSocketService</code> expose une méthode permettant de s&#39;abonner aux nouveaux messages reçus en temps réel. Utilisez cette méthode pour vous abonner aux nouveaux messages dans le composant <code>Room.vue</code>.</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>N&#39;oubliez pas que les messages sont lus depuis le <em>state</em>. Pour modifier le <em>state</em> et donc rajouter un message, utilisez le store <code>MessageStore</code>.</p></div><h3 id="_2-afficher-le-contenu-multimedia" tabindex="-1">2. Afficher le contenu multimédia <a class="header-anchor" href="#_2-afficher-le-contenu-multimedia" aria-label="Permalink to &quot;2. Afficher le contenu multimédia&quot;">​</a></h3><p><img src="'+t+'" alt="Youtube"></p><p>Un message peut contenir des liens vers divers contenus multimédia. Les liens contenus dans les messages sont analysés par le service <code>src/modules/message/services/MessageDataparser.ts</code>.</p><p>La méthode <code>extractAttachements</code> doit parcourir les <code>tokens</code> du <code>RichText</code> du message pour trouver les liens et les analyser. Un lien est un <code>token</code> de type <code>link</code>.</p><p>La méthode doit retourner un tableau de <code>MessageAttachement</code>.</p><p>Utilisez les Regex fournis pour déterminer le type d&#39;attachement.</p><p>Les différents attachements sont <code>WebsiteMessageAttachement</code>, <code>YoutubeMessageAttachement</code>, <code>ImageMessageAttachement</code>, <code>AudioMessageAttachement</code>, <code>VideoMessageAttachement</code>. (<code>src/modules/message/models/domain/RichMessage.ts</code>)</p><p>Chaque type d&#39;attachement à un composant permettant de l&#39;afficher. Ces composants se trouvent dans le dossier <code>src/app/components/message/attachements</code>.</p><p>Les attachements doivent être affiché sous le texte dans la <code>DIV</code> <code>message-content</code> du composant <code>Message.vue</code>.</p><h3 id="_3-remplacer-les-liens-http-et-les-mentions" tabindex="-1">3. Remplacer les liens HTTP et les mentions <a class="header-anchor" href="#_3-remplacer-les-liens-http-et-les-mentions" aria-label="Permalink to &quot;3. Remplacer les liens HTTP et les mentions&quot;">​</a></h3><p>Rendre les liens HTTP cliquables et mettre les mentions d&#39;utilisateurs (@username) en valeurs (en gras, en couleur...)</p><h3 id="_4-ajouter-les-reactions" tabindex="-1">4. Ajouter les réactions <a class="header-anchor" href="#_4-ajouter-les-reactions" aria-label="Permalink to &quot;4. Ajouter les réactions&quot;">​</a></h3><p><img src="'+l+`" alt="Reactions"></p><p>Pour réagir à un message, il faut pouvoir sélectionner un emoji. L&#39;emoji-picker utilisé dans le composant <code>Message.vue</code> émet l&#39;évènement <code>pick</code> quand un emoji est sélectionné.</p><p>Implémenté la fonction <code>onEmojiPicked()</code> en vous aidant du <code>MessageService</code> pour réagir à un message.</p><p>Le composant <code>MessageReactions.vue</code> permet d&#39;afficher les réactions reçus par un message.</p><p>Utilisez le bouton ci-dessous pour afficher toutes les réactions :</p><div class="language-HTML vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">HTML</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">button</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#B392F0;">class</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;message-reaction&quot;</span></span>
<span class="line"><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">	&lt;</span><span style="color:#85E89D;">div</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">class</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;message-reaction-emoji&quot;</span><span style="color:#E1E4E8;">&gt;&lt;/</span><span style="color:#85E89D;">div</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">	&lt;</span><span style="color:#85E89D;">div</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">class</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;message-reaction-count&quot;</span><span style="color:#E1E4E8;">&gt;&lt;/</span><span style="color:#85E89D;">div</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;/</span><span style="color:#85E89D;">button</span><span style="color:#E1E4E8;">&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#22863A;">button</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#6F42C1;">class</span><span style="color:#24292E;">=</span><span style="color:#032F62;">&quot;message-reaction&quot;</span></span>
<span class="line"><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">	&lt;</span><span style="color:#22863A;">div</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">class</span><span style="color:#24292E;">=</span><span style="color:#032F62;">&quot;message-reaction-emoji&quot;</span><span style="color:#24292E;">&gt;&lt;/</span><span style="color:#22863A;">div</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">	&lt;</span><span style="color:#22863A;">div</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">class</span><span style="color:#24292E;">=</span><span style="color:#032F62;">&quot;message-reaction-count&quot;</span><span style="color:#24292E;">&gt;&lt;/</span><span style="color:#22863A;">div</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">&lt;/</span><span style="color:#22863A;">button</span><span style="color:#24292E;">&gt;</span></span></code></pre></div><p>Appliquer la classe <code>user-reacted</code> sur le bouton pour indiquer si il s&#39;agit d&#39;une réaction faite par l&#39;utilisateur connecté.</p><p>Le bouton au clic doit emmètre l&#39;évènement <code>reactionClick</code>. Il faudra donc s&#39;abonner à cet évènement pour savoir.</p><p>En résumé :</p><ul><li>Un clic depuis l&#39;emoji-picker rajoute une réaction.</li><li>Au clic sur une réaction on rajoute un réaction aux nombre de réaction déjà présentes.</li><li>Si l&#39;utilisateur connecté reclique sur une de ses précédentes réaction, alors elle est supprimée.</li><li>Les réactions doivent se trouver en dessous des attachements</li></ul><h3 id="_5-infinite-scrolling" tabindex="-1">5. Infinite Scrolling <a class="header-anchor" href="#_5-infinite-scrolling" aria-label="Permalink to &quot;5. Infinite Scrolling&quot;">​</a></h3><p>En l&#39;état, l&#39;application n&#39;affiche que 20 messages maximum. Pour éviter de recevoir trop de message d&#39;un coup du serveur, les messages sont paginés.</p><p>Dans le cas d&#39;une messagerie, il faut que les messages soient chargés au fil du scroll.</p><p>Utilisez la fonction <a href="https://vueuse.org/core/useIntersectionObserver/" target="_blank" rel="noreferrer"><code>useIntersectionObserver</code></a> du package <code>@vueuse/core</code>. Cette fonction utilise l&#39;API de <a href="https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserver/IntersectionObserver" target="_blank" rel="noreferrer">IntersectionObserver</a> et permet de savoir quand un élément présent dans le DOM entre dans la zone visible de l&#39;écran.</p>`,71),r=[c];function i(d,u,m,E,y,h){return s(),a("div",null,r)}const q=e(p,[["render",i]]);export{v as __pageData,q as default};
